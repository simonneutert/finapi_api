=begin
#finAPI RESTful Services (alpha build)

#finAPI RESTful Services (alpha build)

OpenAPI spec version: finAPI PSD2-alpha (based on v.1.73.0)

Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 2.4.7

=end

require 'date'

module FinapiApi
  # Container for a transaction's data
  class Transaction
    # Transaction identifier
    attr_accessor :id

    # Parent transaction identifier
    attr_accessor :parent_id

    # Account identifier
    attr_accessor :account_id

    # Value date in the format 'YYYY-MM-DD HH:MM:SS.SSS' (german time).
    attr_accessor :value_date

    # Bank booking date in the format 'YYYY-MM-DD HH:MM:SS.SSS' (german time).
    attr_accessor :bank_booking_date

    # finAPI Booking date in the format 'YYYY-MM-DD HH:MM:SS.SSS' (german time). NOTE: In some cases, banks may deliver transactions that are booked in future, but already included in the current account balance. To keep the account balance consistent with the set of transactions, such \"future transactions\" will be imported with their finapiBookingDate set to the current date (i.e.: date of import). The finapiBookingDate will automatically get adjusted towards the bankBookingDate each time the associated bank account is updated. Example: A transaction is imported on July, 3rd, with a bank reported booking date of July, 6th. The transaction will be imported with its finapiBookingDate set to July, 3rd. Then, on July 4th, the associated account is updated. During this update, the transaction's finapiBookingDate will be automatically adjusted to July 4th. This adjustment of the finapiBookingDate takes place on each update until the bank account is updated on July 6th or later, in which case the transaction's finapiBookingDate will be adjusted to its final value, July 6th.<br/> The finapiBookingDate is the date that is used by the finAPI PFM services. E.g. when you calculate the spendings of an account for the current month, and have a transaction with finapiBookingDate in the current month but bankBookingDate at the beginning of the next month, then this transaction is included in the calculations (as the bank has this transaction's amount included in the current account balance as well).
    attr_accessor :finapi_booking_date

    # Transaction amount
    attr_accessor :amount

    # Transaction purpose. Maximum length: 2000
    attr_accessor :purpose

    # Counterpart name. Maximum length: 80
    attr_accessor :counterpart_name

    # Counterpart account number
    attr_accessor :counterpart_account_number

    # Counterpart IBAN
    attr_accessor :counterpart_iban

    # Counterpart BLZ
    attr_accessor :counterpart_blz

    # Counterpart BIC
    attr_accessor :counterpart_bic

    # Counterpart Bank name
    attr_accessor :counterpart_bank_name

    # The mandate reference of the counterpart
    attr_accessor :counterpart_mandate_reference

    # The customer reference of the counterpart
    attr_accessor :counterpart_customer_reference

    # The creditor ID of the counterpart. Exists only for SEPA direct debit transactions (\"Lastschrift\").
    attr_accessor :counterpart_creditor_id

    # The originator's identification code. Exists only for SEPA money transfer transactions (\"Ãœberweisung\").
    attr_accessor :counterpart_debitor_id

    # Transaction type, according to the bank. If set, this will contain a German term that you can display to the user. Some examples of common values are: \"Lastschrift\", \"Auslands&uuml;berweisung\", \"Geb&uuml;hren\", \"Zinsen\". The maximum possible length of this field is 255 characters.
    attr_accessor :type

    # ZKA business transaction code which relates to the transaction's type. Possible values range from 1 through 999. If no information about the ZKA type code is available, then this field will be null.
    attr_accessor :type_code_zka

    # SWIFT transaction type code. If no information about the SWIFT code is available, then this field will be null.
    attr_accessor :type_code_swift

    # SEPA purpose code, according to ISO 20022
    attr_accessor :sepa_purpose_code

    # Transaction primanota (bank side identification number)
    attr_accessor :primanota

    # Transaction category, if any is assigned. Note: Recently imported transactions that have currently no category assigned might still get categorized by the background categorization process. To check the status of the background categorization, see GET /bankConnections. Manual category assignments to a transaction will remove the transaction from the background categorization process (i.e. the background categorization process will never overwrite a manual category assignment).
    attr_accessor :category

    # Array of assigned labels
    attr_accessor :labels

    # While finAPI uses a well-elaborated algorithm for uniquely identifying transactions, there is still the possibility that during an account update, a transaction that was imported previously may be imported a second time as a new transaction. For example, this can happen if some transaction data changes on the bank server side. However, finAPI also includes an algorithm of identifying such \"potential duplicate\" transactions. If this field is set to true, it means that finAPI detected a similar transaction that might actually be the same. It is recommended to communicate this information to the end user, and give him an option to delete the transaction in case he confirms that it really is a duplicate.
    attr_accessor :is_potential_duplicate

    # Indicating whether this transaction is an adjusting entry ('Zwischensaldo').<br/><br/>Adjusting entries do not originate from the bank, but are added by finAPI during an account update when the bank reported account balance does not add up to the set of transactions that finAPI receives for the account. In this case, the adjusting entry will fix the deviation between the balance and the received transactions so that both adds up again.<br/><br/>Possible causes for such deviations are:<br/>- Inconsistencies in how the bank calculates the balance, for instance when not yet booked transactions are already included in the balance, but not included in the set of transactions<br/>- Gaps in the transaction history that finAPI receives, for instance because the account has not been updated for a while and older transactions are no longer available
    attr_accessor :is_adjusting_entry

    # Indicating whether this transaction is 'new' or not. Any newly imported transaction will have this flag initially set to true. How you use this field is up to your interpretation. For example, you might want to set it to false once a user has clicked on/seen the transaction. You can change this flag to 'false' with the PATCH method.
    attr_accessor :is_new

    # Date of transaction import, in the format 'YYYY-MM-DD HH:MM:SS.SSS' (german time).
    attr_accessor :import_date

    # Sub-transactions identifiers (if this transaction is split)
    attr_accessor :children

    # Additional, PayPal-specific transaction data. This field is only set for transactions that belong to an account of the 'PayPal' bank (BLZ 'PAYPAL').<br/>NOTE: This field is deprecated as the bank with blz 'PAYPAL' is no longer supported. Do not use this field, as it will be removed at some point.
    attr_accessor :paypal_data

    # End-To-End reference
    attr_accessor :end_to_end_reference

    # Compensation Amount. Sum of reimbursement of out-of-pocket expenses plus processing brokerage in case of a national return / refund debit as well as an optional interest equalisation. Exists predominantly for SEPA direct debit returns.
    attr_accessor :compensation_amount

    # Original Amount of the original direct debit. Exists predominantly for SEPA direct debit returns.
    attr_accessor :original_amount

    # Payer's/debtor's reference party (in the case of a credit transfer) or payee's/creditor's reference party (in the case of a direct debit)
    attr_accessor :different_debitor

    # Payee's/creditor's reference party (in the case of a credit transfer) or payer's/debtor's reference party (in the case of a direct debit)
    attr_accessor :different_creditor

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        :'id' => :'id',
        :'parent_id' => :'parentId',
        :'account_id' => :'accountId',
        :'value_date' => :'valueDate',
        :'bank_booking_date' => :'bankBookingDate',
        :'finapi_booking_date' => :'finapiBookingDate',
        :'amount' => :'amount',
        :'purpose' => :'purpose',
        :'counterpart_name' => :'counterpartName',
        :'counterpart_account_number' => :'counterpartAccountNumber',
        :'counterpart_iban' => :'counterpartIban',
        :'counterpart_blz' => :'counterpartBlz',
        :'counterpart_bic' => :'counterpartBic',
        :'counterpart_bank_name' => :'counterpartBankName',
        :'counterpart_mandate_reference' => :'counterpartMandateReference',
        :'counterpart_customer_reference' => :'counterpartCustomerReference',
        :'counterpart_creditor_id' => :'counterpartCreditorId',
        :'counterpart_debitor_id' => :'counterpartDebitorId',
        :'type' => :'type',
        :'type_code_zka' => :'typeCodeZka',
        :'type_code_swift' => :'typeCodeSwift',
        :'sepa_purpose_code' => :'sepaPurposeCode',
        :'primanota' => :'primanota',
        :'category' => :'category',
        :'labels' => :'labels',
        :'is_potential_duplicate' => :'isPotentialDuplicate',
        :'is_adjusting_entry' => :'isAdjustingEntry',
        :'is_new' => :'isNew',
        :'import_date' => :'importDate',
        :'children' => :'children',
        :'paypal_data' => :'paypalData',
        :'end_to_end_reference' => :'endToEndReference',
        :'compensation_amount' => :'compensationAmount',
        :'original_amount' => :'originalAmount',
        :'different_debitor' => :'differentDebitor',
        :'different_creditor' => :'differentCreditor'
      }
    end

    # Attribute type mapping.
    def self.swagger_types
      {
        :'id' => :'Integer',
        :'parent_id' => :'Integer',
        :'account_id' => :'Integer',
        :'value_date' => :'String',
        :'bank_booking_date' => :'String',
        :'finapi_booking_date' => :'String',
        :'amount' => :'Float',
        :'purpose' => :'String',
        :'counterpart_name' => :'String',
        :'counterpart_account_number' => :'String',
        :'counterpart_iban' => :'String',
        :'counterpart_blz' => :'String',
        :'counterpart_bic' => :'String',
        :'counterpart_bank_name' => :'String',
        :'counterpart_mandate_reference' => :'String',
        :'counterpart_customer_reference' => :'String',
        :'counterpart_creditor_id' => :'String',
        :'counterpart_debitor_id' => :'String',
        :'type' => :'String',
        :'type_code_zka' => :'String',
        :'type_code_swift' => :'String',
        :'sepa_purpose_code' => :'String',
        :'primanota' => :'String',
        :'category' => :'Category',
        :'labels' => :'Array<Label>',
        :'is_potential_duplicate' => :'BOOLEAN',
        :'is_adjusting_entry' => :'BOOLEAN',
        :'is_new' => :'BOOLEAN',
        :'import_date' => :'String',
        :'children' => :'Array<Integer>',
        :'paypal_data' => :'PaypalTransactionData',
        :'end_to_end_reference' => :'String',
        :'compensation_amount' => :'Float',
        :'original_amount' => :'Float',
        :'different_debitor' => :'String',
        :'different_creditor' => :'String'
      }
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      return unless attributes.is_a?(Hash)

      # convert string to symbol for hash key
      attributes = attributes.each_with_object({}) { |(k, v), h| h[k.to_sym] = v }

      if attributes.has_key?(:'id')
        self.id = attributes[:'id']
      end

      if attributes.has_key?(:'parentId')
        self.parent_id = attributes[:'parentId']
      end

      if attributes.has_key?(:'accountId')
        self.account_id = attributes[:'accountId']
      end

      if attributes.has_key?(:'valueDate')
        self.value_date = attributes[:'valueDate']
      end

      if attributes.has_key?(:'bankBookingDate')
        self.bank_booking_date = attributes[:'bankBookingDate']
      end

      if attributes.has_key?(:'finapiBookingDate')
        self.finapi_booking_date = attributes[:'finapiBookingDate']
      end

      if attributes.has_key?(:'amount')
        self.amount = attributes[:'amount']
      end

      if attributes.has_key?(:'purpose')
        self.purpose = attributes[:'purpose']
      end

      if attributes.has_key?(:'counterpartName')
        self.counterpart_name = attributes[:'counterpartName']
      end

      if attributes.has_key?(:'counterpartAccountNumber')
        self.counterpart_account_number = attributes[:'counterpartAccountNumber']
      end

      if attributes.has_key?(:'counterpartIban')
        self.counterpart_iban = attributes[:'counterpartIban']
      end

      if attributes.has_key?(:'counterpartBlz')
        self.counterpart_blz = attributes[:'counterpartBlz']
      end

      if attributes.has_key?(:'counterpartBic')
        self.counterpart_bic = attributes[:'counterpartBic']
      end

      if attributes.has_key?(:'counterpartBankName')
        self.counterpart_bank_name = attributes[:'counterpartBankName']
      end

      if attributes.has_key?(:'counterpartMandateReference')
        self.counterpart_mandate_reference = attributes[:'counterpartMandateReference']
      end

      if attributes.has_key?(:'counterpartCustomerReference')
        self.counterpart_customer_reference = attributes[:'counterpartCustomerReference']
      end

      if attributes.has_key?(:'counterpartCreditorId')
        self.counterpart_creditor_id = attributes[:'counterpartCreditorId']
      end

      if attributes.has_key?(:'counterpartDebitorId')
        self.counterpart_debitor_id = attributes[:'counterpartDebitorId']
      end

      if attributes.has_key?(:'type')
        self.type = attributes[:'type']
      end

      if attributes.has_key?(:'typeCodeZka')
        self.type_code_zka = attributes[:'typeCodeZka']
      end

      if attributes.has_key?(:'typeCodeSwift')
        self.type_code_swift = attributes[:'typeCodeSwift']
      end

      if attributes.has_key?(:'sepaPurposeCode')
        self.sepa_purpose_code = attributes[:'sepaPurposeCode']
      end

      if attributes.has_key?(:'primanota')
        self.primanota = attributes[:'primanota']
      end

      if attributes.has_key?(:'category')
        self.category = attributes[:'category']
      end

      if attributes.has_key?(:'labels')
        if (value = attributes[:'labels']).is_a?(Array)
          self.labels = value
        end
      end

      if attributes.has_key?(:'isPotentialDuplicate')
        self.is_potential_duplicate = attributes[:'isPotentialDuplicate']
      end

      if attributes.has_key?(:'isAdjustingEntry')
        self.is_adjusting_entry = attributes[:'isAdjustingEntry']
      end

      if attributes.has_key?(:'isNew')
        self.is_new = attributes[:'isNew']
      end

      if attributes.has_key?(:'importDate')
        self.import_date = attributes[:'importDate']
      end

      if attributes.has_key?(:'children')
        if (value = attributes[:'children']).is_a?(Array)
          self.children = value
        end
      end

      if attributes.has_key?(:'paypalData')
        self.paypal_data = attributes[:'paypalData']
      end

      if attributes.has_key?(:'endToEndReference')
        self.end_to_end_reference = attributes[:'endToEndReference']
      end

      if attributes.has_key?(:'compensationAmount')
        self.compensation_amount = attributes[:'compensationAmount']
      end

      if attributes.has_key?(:'originalAmount')
        self.original_amount = attributes[:'originalAmount']
      end

      if attributes.has_key?(:'differentDebitor')
        self.different_debitor = attributes[:'differentDebitor']
      end

      if attributes.has_key?(:'differentCreditor')
        self.different_creditor = attributes[:'differentCreditor']
      end
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = Array.new
      if @id.nil?
        invalid_properties.push('invalid value for "id", id cannot be nil.')
      end

      if @account_id.nil?
        invalid_properties.push('invalid value for "account_id", account_id cannot be nil.')
      end

      if @value_date.nil?
        invalid_properties.push('invalid value for "value_date", value_date cannot be nil.')
      end

      if @bank_booking_date.nil?
        invalid_properties.push('invalid value for "bank_booking_date", bank_booking_date cannot be nil.')
      end

      if @finapi_booking_date.nil?
        invalid_properties.push('invalid value for "finapi_booking_date", finapi_booking_date cannot be nil.')
      end

      if @amount.nil?
        invalid_properties.push('invalid value for "amount", amount cannot be nil.')
      end

      if @is_potential_duplicate.nil?
        invalid_properties.push('invalid value for "is_potential_duplicate", is_potential_duplicate cannot be nil.')
      end

      if @is_adjusting_entry.nil?
        invalid_properties.push('invalid value for "is_adjusting_entry", is_adjusting_entry cannot be nil.')
      end

      if @is_new.nil?
        invalid_properties.push('invalid value for "is_new", is_new cannot be nil.')
      end

      if @import_date.nil?
        invalid_properties.push('invalid value for "import_date", import_date cannot be nil.')
      end

      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      return false if @id.nil?
      return false if @account_id.nil?
      return false if @value_date.nil?
      return false if @bank_booking_date.nil?
      return false if @finapi_booking_date.nil?
      return false if @amount.nil?
      return false if @is_potential_duplicate.nil?
      return false if @is_adjusting_entry.nil?
      return false if @is_new.nil?
      return false if @import_date.nil?
      true
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.equal?(o)
      self.class == o.class &&
          id == o.id &&
          parent_id == o.parent_id &&
          account_id == o.account_id &&
          value_date == o.value_date &&
          bank_booking_date == o.bank_booking_date &&
          finapi_booking_date == o.finapi_booking_date &&
          amount == o.amount &&
          purpose == o.purpose &&
          counterpart_name == o.counterpart_name &&
          counterpart_account_number == o.counterpart_account_number &&
          counterpart_iban == o.counterpart_iban &&
          counterpart_blz == o.counterpart_blz &&
          counterpart_bic == o.counterpart_bic &&
          counterpart_bank_name == o.counterpart_bank_name &&
          counterpart_mandate_reference == o.counterpart_mandate_reference &&
          counterpart_customer_reference == o.counterpart_customer_reference &&
          counterpart_creditor_id == o.counterpart_creditor_id &&
          counterpart_debitor_id == o.counterpart_debitor_id &&
          type == o.type &&
          type_code_zka == o.type_code_zka &&
          type_code_swift == o.type_code_swift &&
          sepa_purpose_code == o.sepa_purpose_code &&
          primanota == o.primanota &&
          category == o.category &&
          labels == o.labels &&
          is_potential_duplicate == o.is_potential_duplicate &&
          is_adjusting_entry == o.is_adjusting_entry &&
          is_new == o.is_new &&
          import_date == o.import_date &&
          children == o.children &&
          paypal_data == o.paypal_data &&
          end_to_end_reference == o.end_to_end_reference &&
          compensation_amount == o.compensation_amount &&
          original_amount == o.original_amount &&
          different_debitor == o.different_debitor &&
          different_creditor == o.different_creditor
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [Fixnum] Hash code
    def hash
      [id, parent_id, account_id, value_date, bank_booking_date, finapi_booking_date, amount, purpose, counterpart_name, counterpart_account_number, counterpart_iban, counterpart_blz, counterpart_bic, counterpart_bank_name, counterpart_mandate_reference, counterpart_customer_reference, counterpart_creditor_id, counterpart_debitor_id, type, type_code_zka, type_code_swift, sepa_purpose_code, primanota, category, labels, is_potential_duplicate, is_adjusting_entry, is_new, import_date, children, paypal_data, end_to_end_reference, compensation_amount, original_amount, different_debitor, different_creditor].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      self.class.swagger_types.each_pair do |key, type|
        if type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            self.send("#{key}=", attributes[self.class.attribute_map[key]].map { |v| _deserialize($1, v) })
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          self.send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        end # or else data not found in attributes(hash), not an issue as the data can be optional
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :DateTime
        DateTime.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :BOOLEAN
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        temp_model = FinapiApi.const_get(type).new
        temp_model.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        next if value.nil?
        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end
  end
end
