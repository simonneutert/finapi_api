=begin
#finAPI RESTful Services (alpha build)

#finAPI RESTful Services (alpha build)

OpenAPI spec version: finAPI PSD2-alpha (based on v.1.73.0)

Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 2.4.7

=end

require 'date'

module FinapiApiClient
  # Container for a bank's data
  class Bank
    # Bank identifier.<br/><br/>NOTE: Do NOT assume that the identifiers of banks are the same across different finAPI environments. In fact, the identifiers may change whenever a new finAPI version is released, even within the same environment. The identifiers are meant to be used for references within the finAPI services only, but not for hard-coding them in your application. If you need to hard-code the usage of a certain bank within your application, please instead refer to the BLZ.
    attr_accessor :id

    # Name of bank
    attr_accessor :name

    # THIS FIELD IS DEPRECATED AND WILL BE REMOVED. Refer to the 'loginHint' in the 'interfaces' instead.<br/><br/>Login hint. Contains a German message for the user that explains what kind of credentials are expected.<br/><br/>Please note that it is strongly recommended to always show the login hint to the user if there is one, as the credentials that finAPI requires for the bank might be different to the credentials that the user knows from the bank's website.<br/><br/>Also note that the contents of this field should always be interpreted as HTML, as the text might contain HTML tags for highlighted words, paragraphs, etc.
    attr_accessor :login_hint

    # BIC of bank
    attr_accessor :bic

    # BLZ of bank
    attr_accessor :blz

    # THIS FIELD IS DEPRECATED AND WILL BE REMOVED. Refer to the 'blz' field instead.
    attr_accessor :blzs

    # THIS FIELD IS DEPRECATED AND WILL BE REMOVED. Refer to the 'loginCredentials' in the 'interfaces' instead.<br/><br/>Label for the user ID login field, as it is called on the bank's website (e.g. \"Nutzerkennung\"). If this field is set (i.e. not null) then you should prompt your users to enter the required data in a text field which you can label with this field's value.
    attr_accessor :login_field_user_id

    # THIS FIELD IS DEPRECATED AND WILL BE REMOVED. Refer to the 'loginCredentials' in the 'interfaces' instead.<br/><br/>Label for the customer ID login field, as it is called on the bank's website (e.g. \"Kundennummer\"). If this field is set (i.e. not null) then you should prompt your users to enter the required data in a text field which you can label with this field's value.
    attr_accessor :login_field_customer_id

    # THIS FIELD IS DEPRECATED AND WILL BE REMOVED. Refer to the 'loginCredentials' in the 'interfaces' instead.<br/><br/>Label for the PIN field, as it is called on the bank's website (mostly \"PIN\"). If this field is set (i.e. not null) then you should prompt your users to enter the required data in a text field which you can label with this field's value.
    attr_accessor :login_field_pin

    # THIS FIELD IS DEPRECATED AND WILL BE REMOVED. Refer to the 'isSecret' field of the 'loginCredentials' in 'interfaces' instead.<br/><br/>Whether the banking customer ID has to be treated like a password. Certain banks require a second password (besides the PIN) for the user to login. In this case your application should use a password input field when prompting users for their credentials.<br><br>NOTE: This field is deprecated and will be removed at some point. 
    attr_accessor :is_customer_id_password

    # Whether this bank is supported by finAPI, i.e. whether you can import/update a bank connection of this bank.<br><br>NOTE: This field is deprecated and will be removed at some point. Please refer to field 'interfaces' instead.
    attr_accessor :is_supported

    # THIS FIELD IS DEPRECATED AND WILL BE REMOVED. Refer to the 'interfaces' instead.<br/><br/>List of the data sources that finAPI will use for data download for this bank. Possible values:<br><br>&bull; <code>FINTS_SERVER</code> - means that finAPI will download data via the bank's FinTS interface.<br>&bull; <code>WEB_SCRAPER</code> - means that finAPI will parse data from the bank's online banking website.<br><br>Note that this list will be empty for non-supported banks. Note also that web scraping might be disabled for your client (see GET /clientConfiguration). When this is the case, then finAPI will not use the web scraper for data download, and if the web scraper is the only supported data source of this bank, then finAPI will not allow to download any data for this bank at all (for details, see POST /bankConnections/import and POST /bankConnections/update).
    attr_accessor :supported_data_sources

    # Set of interfaces that finAPI can use to connect to the bank. Note that this set will be empty for non-supported banks. Note also that the WEB_SCRAPER interface might be disabled for your client (see GET /clientConfiguration). When this is the case, then finAPI will not use the web scraper for data download, and if the web scraper is the only supported interface of this bank, then finAPI will not allow to download any data for this bank at all (for details, see POST /bankConnections/import and POST /bankConnections/update).
    attr_accessor :interfaces

    # THIS FIELD IS DEPRECATED AND WILL BE REMOVED. Refer to the 'isVolatile' field of the 'loginCredentials' in 'interfaces' instead.<br/><br/>Whether the PINs that are used for authentication with the bank are volatile. If the PINs are volatile, it means that a PIN is usually valid only for a single authentication, and is then invalidated. If a bank uses volatile PINs, it is strongly inadvisable to store PINs in finAPI, as a stored PIN will not work for future authentications.<br><br>NOTE: This field is deprecated and will be removed at some point.
    attr_accessor :pins_are_volatile

    # Bank location (two-letter country code; ISO 3166 ALPHA-2). Note that when this field is not set, it means that this bank depicts an international institute which is not bound to any specific country.
    attr_accessor :location

    # City that this bank is located in. Note that this field may not be set for some banks.
    attr_accessor :city

    # If true, then this bank does not depict a real bank, but rather a testing endpoint provided by a bank or by finAPI. You probably want to regard these banks only during the development of your application, but not in production. You can filter out these banks in production by making sure that the 'isTestBank' parameter is always set to 'false' whenever your application is calling the 'Get and search all banks' service.
    attr_accessor :is_test_bank

    # Popularity of this bank with your users (mandator-wide, i.e. across all of your clients). The value equals the number of bank connections that are currently imported for this bank across all of your users (which means it is a constantly adjusting value). You can use this field for statistical evaluation, and also for ordering bank search results (see service 'Get and search all banks').
    attr_accessor :popularity

    # The health status of this bank. This is a value between 0 and 100, depicting the percentage of successful communication attempts with this bank during the latest couple of bank connection imports or updates (across the entire finAPI system). Note that 'successful' means that there was no technical error trying to establish a communication with the bank. Non-technical errors (like incorrect credentials) are regarded successful communication attempts.
    attr_accessor :health

    # Time of the last communication attempt with this bank during a bank connection import or update (across the entire finAPI system). The value is returned in the format 'YYYY-MM-DD HH:MM:SS.SSS' (german time).
    attr_accessor :last_communication_attempt

    # Time of the last successful communication with this bank during a bank connection import or update (across the entire finAPI system). The value is returned in the format 'YYYY-MM-DD HH:MM:SS.SSS' (german time).
    attr_accessor :last_successful_communication

    class EnumAttributeValidator
      attr_reader :datatype
      attr_reader :allowable_values

      def initialize(datatype, allowable_values)
        @allowable_values = allowable_values.map do |value|
          case datatype.to_s
          when /Integer/i
            value.to_i
          when /Float/i
            value.to_f
          else
            value
          end
        end
      end

      def valid?(value)
        !value || allowable_values.include?(value)
      end
    end

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        :'id' => :'id',
        :'name' => :'name',
        :'login_hint' => :'loginHint',
        :'bic' => :'bic',
        :'blz' => :'blz',
        :'blzs' => :'blzs',
        :'login_field_user_id' => :'loginFieldUserId',
        :'login_field_customer_id' => :'loginFieldCustomerId',
        :'login_field_pin' => :'loginFieldPin',
        :'is_customer_id_password' => :'isCustomerIdPassword',
        :'is_supported' => :'isSupported',
        :'supported_data_sources' => :'supportedDataSources',
        :'interfaces' => :'interfaces',
        :'pins_are_volatile' => :'pinsAreVolatile',
        :'location' => :'location',
        :'city' => :'city',
        :'is_test_bank' => :'isTestBank',
        :'popularity' => :'popularity',
        :'health' => :'health',
        :'last_communication_attempt' => :'lastCommunicationAttempt',
        :'last_successful_communication' => :'lastSuccessfulCommunication'
      }
    end

    # Attribute type mapping.
    def self.swagger_types
      {
        :'id' => :'Integer',
        :'name' => :'String',
        :'login_hint' => :'String',
        :'bic' => :'String',
        :'blz' => :'String',
        :'blzs' => :'Array<String>',
        :'login_field_user_id' => :'String',
        :'login_field_customer_id' => :'String',
        :'login_field_pin' => :'String',
        :'is_customer_id_password' => :'BOOLEAN',
        :'is_supported' => :'BOOLEAN',
        :'supported_data_sources' => :'Array<String>',
        :'interfaces' => :'Array<BankInterface>',
        :'pins_are_volatile' => :'BOOLEAN',
        :'location' => :'String',
        :'city' => :'String',
        :'is_test_bank' => :'BOOLEAN',
        :'popularity' => :'Integer',
        :'health' => :'Integer',
        :'last_communication_attempt' => :'String',
        :'last_successful_communication' => :'String'
      }
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      return unless attributes.is_a?(Hash)

      # convert string to symbol for hash key
      attributes = attributes.each_with_object({}) { |(k, v), h| h[k.to_sym] = v }

      if attributes.has_key?(:'id')
        self.id = attributes[:'id']
      end

      if attributes.has_key?(:'name')
        self.name = attributes[:'name']
      end

      if attributes.has_key?(:'loginHint')
        self.login_hint = attributes[:'loginHint']
      end

      if attributes.has_key?(:'bic')
        self.bic = attributes[:'bic']
      end

      if attributes.has_key?(:'blz')
        self.blz = attributes[:'blz']
      end

      if attributes.has_key?(:'blzs')
        if (value = attributes[:'blzs']).is_a?(Array)
          self.blzs = value
        end
      end

      if attributes.has_key?(:'loginFieldUserId')
        self.login_field_user_id = attributes[:'loginFieldUserId']
      end

      if attributes.has_key?(:'loginFieldCustomerId')
        self.login_field_customer_id = attributes[:'loginFieldCustomerId']
      end

      if attributes.has_key?(:'loginFieldPin')
        self.login_field_pin = attributes[:'loginFieldPin']
      end

      if attributes.has_key?(:'isCustomerIdPassword')
        self.is_customer_id_password = attributes[:'isCustomerIdPassword']
      end

      if attributes.has_key?(:'isSupported')
        self.is_supported = attributes[:'isSupported']
      end

      if attributes.has_key?(:'supportedDataSources')
        if (value = attributes[:'supportedDataSources']).is_a?(Array)
          self.supported_data_sources = value
        end
      end

      if attributes.has_key?(:'interfaces')
        if (value = attributes[:'interfaces']).is_a?(Array)
          self.interfaces = value
        end
      end

      if attributes.has_key?(:'pinsAreVolatile')
        self.pins_are_volatile = attributes[:'pinsAreVolatile']
      end

      if attributes.has_key?(:'location')
        self.location = attributes[:'location']
      end

      if attributes.has_key?(:'city')
        self.city = attributes[:'city']
      end

      if attributes.has_key?(:'isTestBank')
        self.is_test_bank = attributes[:'isTestBank']
      end

      if attributes.has_key?(:'popularity')
        self.popularity = attributes[:'popularity']
      end

      if attributes.has_key?(:'health')
        self.health = attributes[:'health']
      end

      if attributes.has_key?(:'lastCommunicationAttempt')
        self.last_communication_attempt = attributes[:'lastCommunicationAttempt']
      end

      if attributes.has_key?(:'lastSuccessfulCommunication')
        self.last_successful_communication = attributes[:'lastSuccessfulCommunication']
      end
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = Array.new
      if @id.nil?
        invalid_properties.push('invalid value for "id", id cannot be nil.')
      end

      if @name.nil?
        invalid_properties.push('invalid value for "name", name cannot be nil.')
      end

      if @blz.nil?
        invalid_properties.push('invalid value for "blz", blz cannot be nil.')
      end

      if @blzs.nil?
        invalid_properties.push('invalid value for "blzs", blzs cannot be nil.')
      end

      if @is_customer_id_password.nil?
        invalid_properties.push('invalid value for "is_customer_id_password", is_customer_id_password cannot be nil.')
      end

      if @is_supported.nil?
        invalid_properties.push('invalid value for "is_supported", is_supported cannot be nil.')
      end

      if @supported_data_sources.nil?
        invalid_properties.push('invalid value for "supported_data_sources", supported_data_sources cannot be nil.')
      end

      if @pins_are_volatile.nil?
        invalid_properties.push('invalid value for "pins_are_volatile", pins_are_volatile cannot be nil.')
      end

      if @is_test_bank.nil?
        invalid_properties.push('invalid value for "is_test_bank", is_test_bank cannot be nil.')
      end

      if @popularity.nil?
        invalid_properties.push('invalid value for "popularity", popularity cannot be nil.')
      end

      if @health.nil?
        invalid_properties.push('invalid value for "health", health cannot be nil.')
      end

      if @health > 100
        invalid_properties.push('invalid value for "health", must be smaller than or equal to 100.')
      end

      if @health < 0
        invalid_properties.push('invalid value for "health", must be greater than or equal to 0.')
      end

      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      return false if @id.nil?
      return false if @name.nil?
      return false if @blz.nil?
      return false if @blzs.nil?
      return false if @is_customer_id_password.nil?
      return false if @is_supported.nil?
      return false if @supported_data_sources.nil?
      return false if @pins_are_volatile.nil?
      return false if @is_test_bank.nil?
      return false if @popularity.nil?
      return false if @health.nil?
      return false if @health > 100
      return false if @health < 0
      true
    end

    # Custom attribute writer method with validation
    # @param [Object] health Value to be assigned
    def health=(health)
      if health.nil?
        fail ArgumentError, 'health cannot be nil'
      end

      if health > 100
        fail ArgumentError, 'invalid value for "health", must be smaller than or equal to 100.'
      end

      if health < 0
        fail ArgumentError, 'invalid value for "health", must be greater than or equal to 0.'
      end

      @health = health
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.equal?(o)
      self.class == o.class &&
          id == o.id &&
          name == o.name &&
          login_hint == o.login_hint &&
          bic == o.bic &&
          blz == o.blz &&
          blzs == o.blzs &&
          login_field_user_id == o.login_field_user_id &&
          login_field_customer_id == o.login_field_customer_id &&
          login_field_pin == o.login_field_pin &&
          is_customer_id_password == o.is_customer_id_password &&
          is_supported == o.is_supported &&
          supported_data_sources == o.supported_data_sources &&
          interfaces == o.interfaces &&
          pins_are_volatile == o.pins_are_volatile &&
          location == o.location &&
          city == o.city &&
          is_test_bank == o.is_test_bank &&
          popularity == o.popularity &&
          health == o.health &&
          last_communication_attempt == o.last_communication_attempt &&
          last_successful_communication == o.last_successful_communication
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [Fixnum] Hash code
    def hash
      [id, name, login_hint, bic, blz, blzs, login_field_user_id, login_field_customer_id, login_field_pin, is_customer_id_password, is_supported, supported_data_sources, interfaces, pins_are_volatile, location, city, is_test_bank, popularity, health, last_communication_attempt, last_successful_communication].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      self.class.swagger_types.each_pair do |key, type|
        if type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            self.send("#{key}=", attributes[self.class.attribute_map[key]].map { |v| _deserialize($1, v) })
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          self.send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        end # or else data not found in attributes(hash), not an issue as the data can be optional
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :DateTime
        DateTime.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :BOOLEAN
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        temp_model = FinapiApiClient.const_get(type).new
        temp_model.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        next if value.nil?
        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end
  end
end
